{ Glob } from bun
path from node:path

{ McpServer } from @modelcontextprotocol/sdk/server/mcp.js
{ StdioServerTransport } from @modelcontextprotocol/sdk/server/stdio.js

{ BitbucketToolDeclaration } from ./bitbucket.civet
type { ToolDeclarationRunCallback } from ./tool-declaration.civet
{ logger } from ./logger.civet

// Create server
server := new McpServer {
  title: "Bitbucket MCP Server",
  name: "bitbucket-mcp-server",
  version: "1.0.0",
  description: "Bitbucket MCP server",
}

// Prepare to register tools
{ dirname } := import.meta
civetGlob := new Glob "**/*.civet"
toolsPath := path.join dirname, 'tools'

safeActionCallToOutput := (member: InstanceType<typeof BitbucketToolDeclaration>) ->
  (...args: Parameters<ToolDeclarationRunCallback>) ->
    content: []
      type: "text",
      text: (
        try
          await member.run.apply member, args
        catch actionError error: (actionError as Error).message
      )
        |> JSON.stringify

// All tools are loaded via a glob scan, so we can just iterate over the files and import them
// This means to create new tools you just need to create a new file in `src/tools`
for await file of civetGlob.scan toolsPath {
  const absoluteToolPath = path.join toolsPath, file
  const toolDeclarationModule = await import(absoluteToolPath)
  const toolDeclarationModuleExportedMembers = Object.values toolDeclarationModule
  
  // For each exported member, if it's a tool declaration, register it with the server
  for member of toolDeclarationModuleExportedMembers {
    // Filter out exports that aren't tool declarations
    unless member instanceof BitbucketToolDeclaration {
      continue
    }

    // Register the tool with the server
    server.registerTool(
      member.name,
      member.config,
      // Wrap the run call in a try/catch and return the result in the MCP format
      // @ts-expect-error -- The types are all right here, but the SDK won't know that a `Promise` of the
      // `ToolCallback` is a valid `ToolCallback` (because promises are flattened)
      safeActionCallToOutput member
    )
  }
}

// Create a transport to listen for messages on stdin and send messages on stdout
transport := new StdioServerTransport()

// Start receiving messages on stdin and sending messages on stdout
transport
  |> server.connect
  |> await

logger.info "Server started"
