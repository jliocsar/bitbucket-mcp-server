{ z, type ZodType, type ZodRawShape, type Primitive } from zod
type { ToolAnnotations, ServerRequest, ServerNotification } from @modelcontextprotocol/sdk/types.js
type { McpServer } from @modelcontextprotocol/sdk/server/mcp.js
type { RequestHandlerExtra } from @modelcontextprotocol/sdk/shared/protocol.js

// Translates the input/output schema to a basic object type
// Apparently Zod didn't have this feature, so I wrote this basic implementation
// Maybe I should just use the `zod-to-json-schema` package? Not sure...
export TInferedSchema<T> ::= [K in keyof T]: T[K] < ZodType ? z.infer<T[K]> : never
export TSerializable<T> ::= [K in keyof T]: Primitive | TSerializable<T[K]> | TSerializable<T[K]>[]

export ToolDeclarationConfig ::= {
  inputSchema: ZodRawShape < infer TInputSchema ? TInputSchema : never
  outputSchema?: ZodRawShape < infer TOutputSchema ? TOutputSchema : never
  annotations?: ToolAnnotations
  title: string
  description: string
}

export ToolDeclarationRunCallback<TConfig < ToolDeclarationConfig = ToolDeclarationConfig, TConstructor < new (...args: any[]) => any = new () => any> ::=
  (
    @: ToolDeclaration<TConfig, TConstructor> & InstanceType<TConstructor>,
    args: TInferedSchema<TConfig["inputSchema"] < infer TInputSchema ? TInputSchema : never>,
    extra: RequestHandlerExtra<ServerRequest, ServerNotification>
  ) -> Promise<
    TSerializable<TInferedSchema<TConfig["outputSchema"]>> | TSerializable<TInferedSchema<TConfig["outputSchema"]>>[] | null
  >

export ToolDeclarationArgs<TConfig < ToolDeclarationConfig = ToolDeclarationConfig, TConstructor < new (...args: any[]) => any = new () => any> ::= {
  config: TConfig
  run: ToolDeclarationRunCallback<TConfig, TConstructor>
  name: string
}

// Wraps the tool declaration in a class to make it easier to use
// For now some of the stuff is injected directly into this class (like `bitbucket`), but that
// could change to be injected into the `run` function instead or something of the sort
export class ToolDeclaration<TConfig < ToolDeclarationConfig = ToolDeclarationConfig, TConstructor < new (...args: any[]) => any = new () => any> {
  public readonly config: TConfig
  public readonly run: ToolDeclarationRunCallback<TConfig, TConstructor>
  public readonly name: string

  @(args: ToolDeclarationArgs<TConfig, TConstructor>) {
    @config = args.config
    @run = args.run.bind(@ as any)
    @name = args.name
  }
}

safeActionCallToOutput := <T < ToolDeclaration>(member: T) ->
  (...args: Parameters<ToolDeclarationRunCallback>) ->
    content: []
      type: "text",
      text: (
        try
          await member.run.apply member, args
        catch actionError error: (actionError as Error).message
      )
        |> JSON.stringify

// All tools are loaded via a glob scan, so we can just iterate over the files and import them
// This means to create new tools you just need to create a new file in `src/tools`
export registerTools := <TConfig < ToolDeclarationConfig, T < ToolDeclaration<TConfig>>(tools: Record<string, T>) -> (server: McpServer) -> {
  // Register tools based on the glob pattern
  for await member of Object.values tools {
    // For each exported member, if it's a tool declaration, register it with the server
    // Filter out exports that aren't tool declarations
    unless member instanceof ToolDeclaration {
      continue
    }

    // Register the tool with the server
    server.registerTool(
      member.name,
      member.config,
      // Wrap the run call in a try/catch and return the result in the MCP format
      // @ts-expect-error -- The types are all right here, but the SDK won't know that a `Promise` of the
      // `ToolCallback` is a valid `ToolCallback` (because promises are flattened)
      safeActionCallToOutput member
    )
  }
  
  // Return the server to allow for chaining
  server
}
